import React, { useState, useEffect, useRef } from 'react';
import { Settings as SettingsIcon, Minus, X } from 'lucide-react';
import { getCurrentWindow } from '@tauri-apps/api/window';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import { TodoItem } from './components/TodoItem';
import { AddTodoForm, AddTodoFormRef } from './components/AddTodoForm';
import { Settings } from './components/Settings';
import { ShortcutHelp } from './components/ShortcutHelp';
import { TodoFilter, FilterType } from './components/TodoFilter';
import { SearchBar } from './components/SearchBar';
import { DeleteConfirmDialog } from './components/DeleteConfirmDialog';
import { ConnectionStatus } from './components/ConnectionStatus';
import { useSocket } from './hooks/useSocket';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { AppSettings, Todo } from './types/todo';
import { configManager } from './utils/configManager';
import './App.css';

const DEFAULT_SETTINGS: AppSettings = {
  alwaysOnTop: false,
  detailedMode: false,
  darkMode: 'auto',
  confirmDelete: true,
  customCss: '',
  serverUrl: 'http://localhost:3001'
};

function App() {
  const [settings, setSettings] = useState<AppSettings>(DEFAULT_SETTINGS);
  const [isInitialized, setIsInitialized] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showShortcutHelp, setShowShortcutHelp] = useState(false);
  const [selectedTodos, setSelectedTodos] = useState<Set<string>>(new Set());
  const [currentFilter, setCurrentFilter] = useState<FilterType>('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [showHeader, setShowHeader] = useState(true);
  const [isWindowFocused, setIsWindowFocused] = useState(true);
  const [systemPrefersDark, setSystemPrefersDark] = useState(
    window.matchMedia('(prefers-color-scheme: dark)').matches
  );
  const [deleteConfirm, setDeleteConfirm] = useState<{
    isOpen: boolean;
    todoIds: string[];
    title: string;
    message: string;
  }>({ isOpen: false, todoIds: [], title: '', message: '' });
  const addTodoFormRef = useRef<AddTodoFormRef>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);

  const { todos, connected, connectionStatus, reconnectAttempts, addTodo, updateTodo, deleteTodo, toggleTodo, bulkImport, reorderTodos } = useSocket(settings.serverUrl);

  useEffect(() => {
    const initializeConfig = async () => {
      try {
        console.log('Initializing config manager...');
        await configManager.initialize();
        const appSettings = configManager.getAppSettings();
        console.log('Loaded app settings:', appSettings);
        setSettings({ ...DEFAULT_SETTINGS, ...appSettings });
        setIsInitialized(true);
      } catch (error) {
        console.error('Failed to initialize config:', error);
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: localStorage
        console.log('Attempting localStorage fallback...');
        const savedSettings = localStorage.getItem('todoAppSettings');
        if (savedSettings) {
          console.log('Found saved settings in localStorage:', savedSettings);
          const parsed = JSON.parse(savedSettings);
          setSettings({ ...DEFAULT_SETTINGS, ...parsed });
          setIsInitialized(true);
        } else {
          console.log('No saved settings found in localStorage');
          setIsInitialized(true);
        }
      }
    };

    initializeConfig();
  }, []);

  useEffect(() => {
    // ÂàùÊúüÂåñÂÆå‰∫ÜÂæå„Å´„ÅÆ„Åø‰øùÂ≠òÂá¶ÁêÜ„ÇíÂÆüË°å
    if (!isInitialized) return;

    console.log('üîÑ Settings changed, saving to both localStorage and config file:', settings);

    // localStorage„Å´‰øùÂ≠ò
    try {
      localStorage.setItem('todoAppSettings', JSON.stringify(settings));
      console.log('‚úÖ Settings saved to localStorage');
    } catch (error) {
      console.error('‚ùå Failed to save to localStorage:', error);
    }

    // Ë®≠ÂÆö„Éï„Ç°„Ç§„É´„Å´„ÇÇ‰øùÂ≠ò
    configManager.updateFromAppSettings(settings)
      .then(() => {
        console.log('‚úÖ Settings successfully saved to config file');
      })
      .catch(error => {
        console.error('‚ùå Failed to update config file:', error);
      });
  }, [settings, isInitialized]);

  // TauriÁí∞Â¢É„ÅßAlways On Top„ÇíÈÅ©Áî®
  useEffect(() => {
    const applyAlwaysOnTop = async () => {
      if (!isInitialized) return;

      try {
        // TauriÁí∞Â¢É„Åß„ÅÆ„ÅøÂÆüË°å
        if (typeof window !== 'undefined' && (window as any).__TAURI_INTERNALS__) {
          console.log('üîù Applying always on top setting:', settings.alwaysOnTop);
          const appWindow = getCurrentWindow();
          await appWindow.setAlwaysOnTop(settings.alwaysOnTop);
          console.log('‚úÖ Always on top applied successfully');
        }
      } catch (error) {
        console.error('‚ùå Failed to apply always on top:', error);
      }
    };

    applyAlwaysOnTop();
  }, [settings.alwaysOnTop, isInitialized]);

  useEffect(() => {
    if (settings.customCss) {
      const styleEl = document.getElementById('custom-styles') as HTMLStyleElement;
      if (styleEl) {
        styleEl.textContent = settings.customCss;
      } else {
        const newStyleEl = document.createElement('style');
        newStyleEl.id = 'custom-styles';
        newStyleEl.textContent = settings.customCss;
        document.head.appendChild(newStyleEl);
      }
    }
  }, [settings.customCss]);

  // „Ç∑„Çπ„ÉÜ„É†„ÅÆ„ÉÄ„Éº„ÇØ„É¢„Éº„ÉâË®≠ÂÆö„ÇíÁõ£Ë¶ñ
  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');

    const handleChange = (e: MediaQueryListEvent) => {
      setSystemPrefersDark(e.matches);
    };

    mediaQuery.addEventListener('change', handleChange);

    return () => {
      mediaQuery.removeEventListener('change', handleChange);
    };
  }, []);

  // „Éò„ÉÉ„ÉÄ„ÉºË°®Á§∫Âà∂Âæ°
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      // ÁîªÈù¢‰∏äÈÉ®60px‰ª•ÂÜÖ„Å´„Ç´„Éº„ÇΩ„É´„Åå„ÅÇ„ÇãÂ†¥Âêà„Éò„ÉÉ„ÉÄ„Éº„ÇíË°®Á§∫Ôºà„Éâ„É©„ÉÉ„Ç∞„Åó„ÇÑ„Åô„Åè„Åô„Çã„Åü„ÇÅÁØÑÂõ≤„ÇíÊã°Â§ßÔºâ
      if (e.clientY <= 60) {
        setShowHeader(true);
      } else if (e.clientY > 120) {
        // 120px‰ª•‰∏ã„Å´‰∏ã„Åå„Å£„Åü„Çâ„Éò„ÉÉ„ÉÄ„Éº„ÇíÈö†„ÅôÔºà‰ΩôË£ï„ÇíÊåÅ„Åü„Åõ„ÇãÔºâ
        setShowHeader(false);
      }
    };

    const handleMouseLeave = () => {
      // „Éû„Ç¶„Çπ„Åå„Ç¶„Ç£„É≥„Éâ„Ç¶„ÇíÈõ¢„Çå„Å¶„ÇÇÂç≥Â∫ß„Å´Èö†„Åï„Å™„ÅÑÔºà„Éâ„É©„ÉÉ„Ç∞Êìç‰Ωú„ÇíËÄÉÊÖÆÔºâ
      setTimeout(() => {
        setShowHeader(false);
      }, 1000);
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseleave', handleMouseLeave);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, []);

  // „Ç¶„Ç£„É≥„Éâ„Ç¶„Éï„Ç©„Éº„Ç´„ÇπÁä∂ÊÖã„ÇíÁõ£Ë¶ñ
  useEffect(() => {
    const handleFocus = () => setIsWindowFocused(true);
    const handleBlur = () => setIsWindowFocused(false);

    window.addEventListener('focus', handleFocus);
    window.addEventListener('blur', handleBlur);

    return () => {
      window.removeEventListener('focus', handleFocus);
      window.removeEventListener('blur', handleBlur);
    };
  }, []);

  // „Ç¶„Ç£„É≥„Éâ„Ç¶„Çø„Ç§„Éà„É´„ÇíÊé•Á∂öÁä∂ÊÖã„Å´Âøú„Åò„Å¶Êõ¥Êñ∞
  useEffect(() => {
    const getStatusIcon = () => {
      switch (connectionStatus) {
        case 'connected':
          return '‚óè';
        case 'connecting':
          return '‚óã';
        case 'disconnected':
          return '√ó';
        case 'error':
          return '!';
        default:
          return '?';
      }
    };

    const updateTitle = async () => {
      try {
        const statusIcon = getStatusIcon();
        const reconnectText = reconnectAttempts > 0 ? ` (${reconnectAttempts})` : '';
        const newTitle = `${statusIcon} YuToDo${reconnectText}`;

        // Tauri„ÅÆÂ†¥Âêà
        if (window.__TAURI__) {
          const appWindow = getCurrentWindow();
          await appWindow.setTitle(newTitle);
        } else {
          // „Éñ„É©„Ç¶„Ç∂„ÅÆÂ†¥Âêà
          document.title = newTitle;
        }
      } catch (error) {
        console.error('Failed to update window title:', error);
      }
    };

    updateTitle();
  }, [connectionStatus, reconnectAttempts]);

  const handleSettingsChange = (newSettings: AppSettings) => {
    setSettings(newSettings);
  };

  const handleImportTodos = (importedTodos: Todo[]) => {
    const todosToImport = importedTodos.map(todo => ({
      title: todo.title,
      description: todo.description,
      completed: todo.completed,
      priority: todo.priority,
      scheduledFor: todo.scheduledFor
    }));
    bulkImport(todosToImport);
  };

  // „Ç¶„Ç£„É≥„Éâ„Ç¶„Ç≥„É≥„Éà„É≠„Éº„É´„Éè„É≥„Éâ„É©
  const handleMinimize = async () => {
    try {
      const appWindow = getCurrentWindow();
      await appWindow.minimize();
    } catch (error) {
      console.error('Failed to minimize window:', error);
    }
  };

  const handleClose = async () => {
    try {
      const appWindow = getCurrentWindow();
      await appWindow.close();
    } catch (error) {
      console.error('Failed to close window:', error);
    }
  };

  // „Éò„ÉÉ„ÉÄ„Éº„Éâ„É©„ÉÉ„Ç∞„Éè„É≥„Éâ„É©
  const handleHeaderMouseDown = async (e: React.MouseEvent) => {
    // „Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØ„ÅÆÂ†¥Âêà„ÅØ„Éâ„É©„ÉÉ„Ç∞„Åó„Å™„ÅÑ
    if ((e.target as HTMLElement).closest('button')) {
      return;
    }

    try {
      const appWindow = getCurrentWindow();
      await appWindow.startDragging();
    } catch (error) {
      console.error('Failed to start dragging:', error);
    }
  };

  // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Éè„É≥„Éâ„É©
  const keyboardHandlers = {
    onNewTask: () => {
      addTodoFormRef.current?.focusInput();
    },
    onToggleSettings: () => {
      setShowSettings(prev => !prev);
    },
    onFocusSearch: () => {
      searchInputRef.current?.focus();
    },
    onSelectAll: () => {
      setSelectedTodos(new Set(todos.map(todo => todo.id)));
    },
    onDeleteSelected: () => {
      handleBulkDeleteWithConfirm();
    },
    onShowHelp: () => {
      setShowShortcutHelp(true);
    }
  };

  useKeyboardShortcuts(keyboardHandlers);

  // ÂÆüÈöõ„ÅÆ„ÉÄ„Éº„ÇØ„É¢„Éº„ÉâÁä∂ÊÖã„ÇíË®àÁÆó
  const isDarkMode = settings.darkMode === 'dark' ||
    (settings.darkMode === 'auto' && systemPrefersDark);

  // ÂâäÈô§„Éè„É≥„Éâ„É©„ÉºÔºàË®≠ÂÆö„Å´Âøú„Åò„Å¶Á¢∫Ë™ç„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíË°®Á§∫Ôºâ
  const handleDeleteWithConfirm = (todoId: string) => {
    if (settings.confirmDelete) {
      const todo = todos.find(t => t.id === todoId);
      if (!todo) return;

      setDeleteConfirm({
        isOpen: true,
        todoIds: [todoId],
        title: '„Çø„Çπ„ÇØ„ÇíÂâäÈô§',
        message: `„Äå${todo.title}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`
      });
    } else {
      // Á¢∫Ë™ç„Å™„Åó„ÅßÂç≥Â∫ß„Å´ÂâäÈô§
      deleteTodo(todoId);
    }
  };

  const handleBulkDeleteWithConfirm = () => {
    if (selectedTodos.size === 0) return;

    if (settings.confirmDelete) {
      setDeleteConfirm({
        isOpen: true,
        todoIds: Array.from(selectedTodos),
        title: 'ÈÅ∏Êäû„Åï„Çå„Åü„Çø„Çπ„ÇØ„ÇíÂâäÈô§',
        message: 'ÈÅ∏Êäû„Åï„Çå„Åü„Çø„Çπ„ÇØ„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü'
      });
    } else {
      // Á¢∫Ë™ç„Å™„Åó„ÅßÂç≥Â∫ß„Å´ÂâäÈô§
      selectedTodos.forEach(todoId => {
        deleteTodo(todoId);
      });
      setSelectedTodos(new Set());
    }
  };

  const confirmDelete = () => {
    deleteConfirm.todoIds.forEach(todoId => {
      deleteTodo(todoId);
    });
    setSelectedTodos(new Set());
  };


  // „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Çª„É≥„Çµ„ÉºÔºà„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©ÂåñÔºâ
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // 8pxÁßªÂãï„Åß„Éâ„É©„ÉÉ„Ç∞ÈñãÂßãÔºà„Çà„ÇäËªΩ„Åè„Åô„Çã„Åü„ÇÅÂ∞è„Åï„ÇÅÔºâ
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  // „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Éè„É≥„Éâ„É©„Éº
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      const oldIndex = sortedTodos.findIndex(todo => todo.id === active.id);
      const newIndex = sortedTodos.findIndex(todo => todo.id === over.id);

      const reorderedTodos = arrayMove(sortedTodos, oldIndex, newIndex);

      // Êñ∞„Åó„ÅÑorder„ÇíË®àÁÆó„Åó„Å¶ÈÄÅ‰ø°
      const reorderData = reorderedTodos.map((todo, index) => ({
        id: todo.id,
        order: index
      }));

      reorderTodos(reorderData);
    }
  };

  // „Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Å®Ê§úÁ¥¢„É≠„Ç∏„ÉÉ„ÇØ
  const filteredTodos = todos.filter(todo => {
    const now = new Date();
    const isOverdue = todo.scheduledFor && new Date(todo.scheduledFor) < now && !todo.completed;

    // Ê§úÁ¥¢„ÇØ„Ç®„É™„Åß„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
    const matchesSearch = searchQuery === '' ||
      todo.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (todo.description && todo.description.toLowerCase().includes(searchQuery.toLowerCase()));

    if (!matchesSearch) return false;

    // „Éï„Ç£„É´„Çø„Éº„Åß„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
    switch (currentFilter) {
      case 'completed':
        return todo.completed;
      case 'pending':
        return !todo.completed;
      case 'overdue':
        return isOverdue;
      case 'high':
        return todo.priority === 2;
      case 'medium':
        return todo.priority === 1;
      case 'low':
        return todo.priority === 0;
      default:
        return true;
    }
  });

  // „Éï„Ç£„É´„Çø„Éº„ÅÆ„Ç´„Ç¶„É≥„ÉàË®àÁÆó
  const filterCounts = {
    all: todos.length,
    completed: todos.filter(todo => todo.completed).length,
    pending: todos.filter(todo => !todo.completed).length,
    overdue: todos.filter(todo => {
      const now = new Date();
      return todo.scheduledFor && new Date(todo.scheduledFor) < now && !todo.completed;
    }).length,
    high: todos.filter(todo => todo.priority === 2).length,
    medium: todos.filter(todo => todo.priority === 1).length,
    low: todos.filter(todo => todo.priority === 0).length
  };

  const sortedTodos = [...filteredTodos].sort((a, b) => {
    // „Ç´„Çπ„Çø„É†order„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Åù„Çå„ÇíÂÑ™ÂÖà
    if (a.order !== undefined && b.order !== undefined) {
      return a.order - b.order;
    }

    if (a.completed !== b.completed) {
      return a.completed ? 1 : -1;
    }

    if (a.priority !== b.priority) {
      return b.priority - a.priority;
    }

    if (a.scheduledFor && b.scheduledFor) {
      return new Date(a.scheduledFor).getTime() - new Date(b.scheduledFor).getTime();
    }

    if (a.scheduledFor && !b.scheduledFor) return -1;
    if (!a.scheduledFor && b.scheduledFor) return 1;

    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
  });

  return (
    <div className={`app ${!settings.detailedMode ? 'app--slim' : ''} ${isDarkMode ? 'app--dark' : ''}`}>
      <header className={`app-header ${showHeader ? 'app-header--visible' : 'app-header--hidden'}`} onMouseDown={handleHeaderMouseDown}>
        <div className="header-left">
          <h1>YuToDo</h1>
          {!settings.detailedMode && (
            <ConnectionStatus
              connectionStatus={connectionStatus}
              reconnectAttempts={reconnectAttempts}
              isSlimMode={true}
              className="ml-2"
            />
          )}
        </div>
        <div className="header-center">
          {settings.detailedMode && (
            <ConnectionStatus
              connectionStatus={connectionStatus}
              reconnectAttempts={reconnectAttempts}
              isSlimMode={false}
            />
          )}
        </div>
        <div className="header-right">
          <button
            onClick={() => setShowSettings(true)}
            className="settings-btn"
          >
            <SettingsIcon size={16} />
          </button>
          <button
            onClick={handleMinimize}
            className="window-control minimize-btn"
            title="ÊúÄÂ∞èÂåñ"
          >
            <Minus size={14} />
          </button>
          <button
            onClick={handleClose}
            className="window-control close-btn"
            title="Èñâ„Åò„Çã"
          >
            <X size={14} />
          </button>
        </div>
      </header>

      <main className={`app-main ${showHeader ? 'app-main--with-header' : ''}`}>
        {isWindowFocused && <AddTodoForm ref={addTodoFormRef} onAdd={addTodo} slimMode={!settings.detailedMode} />}

        {isWindowFocused && settings.detailedMode && (
          <>
            <SearchBar
              ref={searchInputRef}
              searchQuery={searchQuery}
              onSearchChange={setSearchQuery}
            />

            <TodoFilter
              currentFilter={currentFilter}
              onFilterChange={setCurrentFilter}
              counts={filterCounts}
            />
          </>
        )}

        <DndContext
          sensors={sensors}
          collisionDetection={closestCenter}
          onDragEnd={handleDragEnd}
          autoScroll={false} // Ëá™Âãï„Çπ„ÇØ„É≠„Éº„É´ÁÑ°ÂäπÂåñ„Åß„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂêë‰∏ä
        >
          <div className="todo-list">
            {sortedTodos.length === 0 ? (
              <div className="empty-state">
                {todos.length === 0 ? (
                  <p>„Çø„Çπ„ÇØ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ‰∏äË®ò„Åã„ÇâÊñ∞„Åó„ÅÑ„Çø„Çπ„ÇØ„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
                ) : (
                  <p>Ê§úÁ¥¢Êù°‰ª∂„Åæ„Åü„ÅØ„Éï„Ç£„É´„Çø„Éº„Å´‰∏ÄËá¥„Åô„Çã„Çø„Çπ„ÇØ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
                )}
              </div>
            ) : (
              <SortableContext
                items={sortedTodos.map(todo => todo.id)}
                strategy={verticalListSortingStrategy}
              >
                {sortedTodos.map((todo) => (
                  <TodoItem
                    key={todo.id}
                    todo={todo}
                    onToggle={toggleTodo}
                    onUpdate={updateTodo}
                    onDelete={handleDeleteWithConfirm}
                    isSelected={selectedTodos.has(todo.id)}
                    slimMode={!settings.detailedMode}
                    onSelect={(id, selected) => {
                      const newSelected = new Set(selectedTodos);
                      if (selected) {
                        newSelected.add(id);
                      } else {
                        newSelected.delete(id);
                      }
                      setSelectedTodos(newSelected);
                    }}
                  />
                ))}
              </SortableContext>
            )}
          </div>
        </DndContext>
      </main>

      {showSettings && (
        <Settings
          settings={settings}
          onSettingsChange={handleSettingsChange}
          onClose={() => setShowSettings(false)}
          todos={todos}
          onImportTodos={handleImportTodos}
          connectionStatus={connectionStatus}
          reconnectAttempts={reconnectAttempts}
        />
      )}

      {showShortcutHelp && (
        <ShortcutHelp
          onClose={() => setShowShortcutHelp(false)}
        />
      )}

      <DeleteConfirmDialog
        isOpen={deleteConfirm.isOpen}
        onClose={() => setDeleteConfirm({ isOpen: false, todoIds: [], title: '', message: '' })}
        onConfirm={confirmDelete}
        title={deleteConfirm.title}
        message={deleteConfirm.message}
        itemCount={deleteConfirm.todoIds.length}
      />
    </div>
  );
}

export default App;
